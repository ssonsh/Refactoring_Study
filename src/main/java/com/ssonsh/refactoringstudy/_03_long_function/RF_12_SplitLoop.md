# ë¦¬íŒ©í† ë§ 12. ë°˜ë³µë¬¸ ìª¼ê°œê¸°

**ëƒ„ìƒˆ** : ê¸´ í•¨ìˆ˜

â†’ **â€œë°˜ë³µë¬¸ ìª¼ê°œê¸°â€** ë¥¼ í†µí•´ ë¦¬íŒ©í† ë§ í•  ìˆ˜ ìˆë‹¤.

### ë°˜ë³µë¬¸ ìª¼ê°œê¸° Split Loop

- í•˜ë‚˜ì˜ ë°˜ë³µë¬¸ì— ì—¬ëŸ¬ ë‹¤ë¥¸ ì‘ì—…ì„ í•˜ëŠ” ì½”ë“œë¥¼ ì‰½ê²Œ ì°¾ì•„ë³¼ ìˆ˜ ìˆë‹¤.
- í•´ë‹¹ ë°˜ë³µë¬¸ì„ ìˆ˜ì •í•  ë–„ ì—¬ëŸ¬ ì‘ì—…ì„ ëª¨ë‘ ê³ ë ¤í•˜ë©° ì½”ë”©ì„ í•´ì•¼ í•œë‹¤.
- ë°˜ë³µë¬¸ì„ ì—¬ëŸ¬ê°œë¡œ ìª¼ê°œë©´ ë³´ë‹¤ ì‰½ê²Œ ì´í•´í•˜ê³  ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤.

<aside>
ğŸˆ ì„±ëŠ¥ ë¬¸ì œë¥¼ ì•¼ê¸°í•  ìˆ˜ ìˆì§€ë§Œ â€œë¦¬íŒ©í† ë§â€ì€ â€œì„±ëŠ¥ ìµœì í™”â€ì™€ ë³„ê°œì˜ ì‘ì—…ì´ë‹¤.

- ë¦¬íŒ©í† ë§ì„ ë§ˆì¹œ ì´í›„ ì„±ëŠ¥ ìµœì í™”ë¥¼ ì‹œë„í•  ìˆ˜ ìˆë‹¤.
</aside>

**ë³´í†µ í•œë²ˆì— ë°˜ë³µë¬¸ ì•ˆì—ì„œ ì—¬ëŸ¬ ì‘ì—…ì„ í•˜ëŠ” ê²½ìš°ê°€ ë§ë‹¤.**

- ì–´ì°¨í”¼ ë°˜ë³µë¬¸ ì•ˆì— ìˆê¸° ë•Œë¬¸ì— ê·¸ëŸ° ê²ƒì¸ë‹¤.
    - íš¨ìœ¨/ì„±ëŠ¥ ì ìœ¼ë¡œ ë§ë‹¤ê³  íŒë‹¨í•˜ê¸° ë–„ë¬¸ì´ë‹¤.
- ê·¸ëŸ¬ë‚˜ ì½”ë“œë¥¼ ìˆ˜ì •í•  ë•Œ ë°˜ë³µë¬¸ í•˜ë‚˜ê°€ ê¸¸ë©´, ê·¸ ì•ˆì˜ ëª¨ë“  ì‘ì—…ì„ ê³ ë ¤í•˜ì—¬ ì‘ì—…í•´ì•¼ í•˜ëŠ” ë‹¨ì ì´ ìˆë‹¤.
- ì •ë§ ì„±ëŠ¥ì ìœ¼ë¡œ ì¹˜ëª…ì ì¸ ë¶€ë¶„ì´ ì•„ë‹ˆë¼ë©´ ë°˜ë³µë¬¸ì„ ê° ì‘ì—…ë§ˆë‹¤ ìª¼ê°œì–´ ë‚˜ëˆ ë†“ê³  ì¶”í›„ ë‹¤ì‹œ ì„±ëŠ¥ì„ ê³ ë ¤í•´ë³´ëŠ” ê²ƒì´ ì¢‹ë‹¤.

**O(n) â†’ ì–¼ë§ˆë‚˜ ì„±ëŠ¥ ì ìœ¼ë¡œ íš¨ìœ¨ì ì¸ê°€?**

- ì•„ë¬´ë¦¬ O(n)ì´ ì—¬ëŸ¬ê°œê°€ ìˆë”ë¼ë„ O(n) ì´ë‹¤.
- ë¬¼ë¡  ë‘ë°°ì´ê¸´ í•˜ì§€ë§Œ.
- ì•Œê³ ë¦¬ì¦˜ ì ìœ¼ë¡œ O(n)ì´ O(n^2) ë˜ëŠ” ê²ƒì€ ì•„ë‹ˆë¼ëŠ” ê²ƒì´ë‹¤.

**ì‹¤ì œë¡œ ì ‘ê·¼ì„ í•´ë³´ê³  ì„±ëŠ¥ì„ ì¸¡ì •í•˜ì—¬ ìƒê°í•˜ì.**

---

**ì•„ë˜ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë³´ì.**

- totalNumberOfEvents ë¥¼ ê¸°ì¤€ìœ¼ë¡œ Loop ê°€ ìˆ˜í–‰ë˜ê³  ìˆê³ 
- ê·¸ ì•ˆì—ì„œëŠ” issueì˜ Commentsë¥¼ Loop í•˜ê³  ìˆë‹¤.
    - ì´ Comments Loop ì—ì„œëŠ” ì•„ë˜ì™€ ê°™ì€ ë‘ê°€ì§€ ì¼ì„ í•˜ê³  ìˆë‹¤.
        - ê³¼ì œë¥¼ ì œì¶œí•œ ì°¸ì—¬ì ì°¾ê¸°
        - ì²«ë²ˆì§¸ë¡œ ê³¼ì œë¥¼ ì œì¶œí•œ ì°¸ì—¬ì ì°¾ê¸°

```java
for (int index = 1; index <= totalNumberOfEvents; index++) {
    int eventId = index;
    service.execute(new Runnable() {
        @Override
        public void run() {
            try {
                GHIssue issue = repository.getIssue(eventId);
                List<GHIssueComment> comments = issue.getComments();

                Date firstCreatedAt = null;
                Participant first = null;
                for (GHIssueComment comment : comments) {
                    Participant participant = findParticipant(comment.getUserName(), participants);
                    participant.setHomeworkDone(eventId);

                    if(firstCreatedAt == null || comment.getCreatedAt().before(firstCreatedAt)){
                        firstCreatedAt = comment.getCreatedAt();
                        first = participant;
                    }
                }
                latch.countDown();
            }
            catch (IOException e) {
                throw new IllegalArgumentException(e);
            }
        }
    });
}
```

**ë¦¬íŒ©í† ë§ í•´ë³´ì - 1ì°¨**

- Loop ë¥¼ ìª¼ê°œë³¸ë‹¤.
    - ê³¼ì œë¥¼ ì œì¶œí•œ ì°¸ì—¬ìë¥¼ ì°¾ëŠ” Loop
    - ê°€ì¥ ì²«ë²ˆì§¸ë¡œ ì œì¶œí•œ ì°¸ì—¬ìë¥¼ ì°¾ëŠ” Loop

```java
for (GHIssueComment comment : comments) {
    Participant participant = findParticipant(comment.getUserName(), participants);
    participant.setHomeworkDone(eventId);
}

Date firstCreatedAt = null;
Participant first = null;
for (GHIssueComment comment : comments) {
    Participant participant = findParticipant(comment.getUserName(), participants);
    if(firstCreatedAt == null || comment.getCreatedAt().before(firstCreatedAt)){
        firstCreatedAt = comment.getCreatedAt();
        first = participant;
    }
}
```

**ë¦¬íŒ©í† ë§ í•´ë³´ì - 2ì°¨**

- Split ëœ Loopë¥¼ í•¨ìˆ˜ë¡œ ì¶”ì¶œí•´ë³¸ë‹¤.

```java
for (int index = 1; index <= totalNumberOfEvents; index++) {
    int eventId = index;
    service.execute(new Runnable() {
        @Override
        public void run() {
            try {
                GHIssue issue = repository.getIssue(eventId);
                List<GHIssueComment> comments = issue.getComments();

                checkHomwork(comments, participants, eventId);
                
                firstParticipantsForEachEvent[eventId - 1] = findFirst(comments, participants);

                latch.countDown();
            }
            catch (IOException e) {
                throw new IllegalArgumentException(e);
            }
        }
    });
}

private Participant findFirst(List<GHIssueComment> comments, List<Participant> participants) throws IOException {
  Date firstCreatedAt = null;
  Participant first = null;
  for (GHIssueComment comment : comments) {
      Participant participant = findParticipant(comment.getUserName(), participants);
      if(firstCreatedAt == null || comment.getCreatedAt().before(firstCreatedAt)){
          firstCreatedAt = comment.getCreatedAt();
          first = participant;
      }
  }
  return first;
}

private void checkHomwork(List<GHIssueComment> comments, List<Participant> participants, int eventId) {
  for (GHIssueComment comment : comments) {
      Participant participant = findParticipant(comment.getUserName(), participants);
      participant.setHomeworkDone(eventId);
  }
}
```

---

```java
ExecutorService service = Executors.newFixedThreadPool(8);
CountDownLatch latch = new CountDownLatch(totalNumberOfEvents);

//

latch.await();
service.shutdown();
```

- MultiThread ë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ExecutorServiceì™€ CountDownLatch

`List<Participant> participants = new CopyOnWriteArrayList<>();`

- Concurrency Safe Collection ì‚¬ìš©

---

ì´í›„ participant ì™€ ê°™ì€ ë§¤ê°œë³€ìˆ˜ê°€ ì—¬ëŸ¬ ë©”ì†Œë“œì˜ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬ë˜ê³  ìˆëŠ”ë°

ì´ëŸ°ë¶€ë¶„ë“¤ì„ í•„ë“œë¡œ ì˜¬ë ¤ì¤„ ìˆ˜ ìˆê²Œ ëœë‹¤.

ê·¸ë ‡ê²Œ ë˜ë©´ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬í•˜ë˜ ë¶€ë¶„ë“¤ì„ ì œê±°í•  ìˆ˜ ìˆê²Œëœë‹¤.

ìµœì¢…ì ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ StudyDashboard.java
```java
package com.ssonsh.refactoringstudy._03_long_function;

import org.kohsuke.github.GHIssue;
import org.kohsuke.github.GHIssueComment;
import org.kohsuke.github.GHRepository;
import org.kohsuke.github.GitHub;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class StudyDashboard {

    private int totalNumberOfEvents;
    private List<Participant> participants;
    private Participant[] firstParticipantsForEachEvent;

    public StudyDashboard(int totalNumberOfEvents) {
        this.totalNumberOfEvents = totalNumberOfEvents;
        this.participants = new CopyOnWriteArrayList<>();
        this.firstParticipantsForEachEvent = new Participant[this.totalNumberOfEvents];
    }

    public static void main(String[] args) throws IOException, InterruptedException {
        StudyDashboard studyDashboard = new StudyDashboard(15);
        studyDashboard.print();
    }

    private void print() throws IOException, InterruptedException {
        GHRepository repository = findGithubRepository();

        checkGithubIssues(repository);

        new StudyPrinter(this.totalNumberOfEvents, this.participants).exeute();
    }

    private GHRepository findGithubRepository() throws IOException {
        GitHub gitHub = GitHub.connect();
        GHRepository repository = gitHub.getRepository("whiteship/live-study");
        return repository;
    }

    private void checkGithubIssues(GHRepository repository) throws
        InterruptedException {
        ExecutorService service = Executors.newFixedThreadPool(8);
        CountDownLatch latch = new CountDownLatch(totalNumberOfEvents);

        for (int index = 1; index <= totalNumberOfEvents; index++) {
            int eventId = index;
            service.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        GHIssue issue = repository.getIssue(eventId);
                        List<GHIssueComment> comments = issue.getComments();
                        checkHomwork(comments, participants, eventId);
                        firstParticipantsForEachEvent[eventId - 1] = findFirst(comments, participants);
                        latch.countDown();
                    }
                    catch (IOException e) {
                        throw new IllegalArgumentException(e);
                    }
                }
            });
        }

        latch.await();
        service.shutdown();
    }

    private Participant findFirst(List<GHIssueComment> comments, List<Participant> participants) throws IOException {
        Date firstCreatedAt = null;
        Participant first = null;
        for (GHIssueComment comment : comments) {
            Participant participant = findParticipant(comment.getUserName(), participants);
            if(firstCreatedAt == null || comment.getCreatedAt().before(firstCreatedAt)){
                firstCreatedAt = comment.getCreatedAt();
                first = participant;
            }
        }
        return first;
    }

    private void checkHomwork(List<GHIssueComment> comments, List<Participant> participants, int eventId) {
        for (GHIssueComment comment : comments) {
            Participant participant = findParticipant(comment.getUserName(), participants);
            participant.setHomeworkDone(eventId);
        }
    }

    private Participant findParticipant(String username, List<Participant> participants) {
        return isNewParticipant(username, participants) ?
               createNewParticipant(username, participants) :
               findExistingParticipant(username, participants);
    }

    private Participant findExistingParticipant(String username, List<Participant> participants) {
        Participant participant;
        participant = participants.stream().filter(p -> p.username().equals(username)).findFirst().orElseThrow();
        return participant;
    }

    private Participant createNewParticipant(String username, List<Participant> participants) {
        Participant participant;
        participant = new Participant(username);
        participants.add(participant);
        return participant;
    }

    private boolean isNewParticipant(String username, List<Participant> participants) {
        return participants.stream().noneMatch(p -> p.username().equals(username));
    }

}
```